# GitHub Actions 워크플로우 이름 정의
name: CI - Multi-Job Detailed

# 워크플로우 실행 조건 정의
on:
  # main 브랜치에 push 이벤트가 발생했을 때 실행
  push:
    branches: [ main ]
  # main 브랜치를 대상으로 하는 pull_request 이벤트가 발생했을 때 실행
  pull_request:
    branches: [ main ]

# 워크플로우를 구성하는 Job들의 목록 정의
jobs:
  # ==============================================================
  # Job 1: CMake 프로젝트 빌드 및 테스트 (Windows 환경)
  # ==============================================================
  # 이 Job의 목적: 소스 코드를 체크아웃하고, vcpkg를 사용하여 의존성을 관리하며,
  # CMake를 통해 프로젝트를 빌드하고, CTest로 단위 테스트를 실행합니다.
  # 빌드 및 테스트 과정을 하나의 Job으로 묶어 관련된 캐시를 효율적으로 사용합니다.
  cmake_build_test:
    # Job의 이름 (GitHub Actions UI에 표시됨)
    name: 1. CMake Build & Test (Windows)
    # Job을 실행할 가상 환경 지정
    # C++ 프로젝트 빌드, 특히 vcpkg 및 MSVC 사용을 위해 Windows 환경 선택
    runs-on: windows-latest

    # Job 내에서 순차적으로 실행될 단계(Step)들의 목록
    steps:
      # --------------------------------------------------------------
      # 단계 1.1: 소스 코드 체크아웃
      # --------------------------------------------------------------
      # 목적: Git 저장소의 소스 코드를 워크플로우 실행 환경으로 가져옵니다.
      - name: 1.1 Check out source code repository
        # 사전 정의된 'actions/checkout' 액션 사용 (v4 버전)
        uses: actions/checkout@v4
        with:
          # submodules: true 옵션: 저장소 내의 Git 서브모듈(여기서는 vcpkg)을 함께 체크아웃합니다.
          submodules: true
          # fetch-depth: 0 옵션: Git 저장소의 전체 히스토리를 가져옵니다.
          # vcpkg는 특정 버전의 라이브러리를 참조하기 위해 'baseline'이라는 Git 커밋 해시를 사용하므로,
          # 얕은 복제(shallow clone, 예: fetch-depth: 1)를 사용하면 필요한 과거 커밋을 찾지 못해 오류가 발생할 수 있습니다.
          # 따라서 vcpkg를 사용할 때는 전체 히스토리를 가져오는 것이 안전합니다.
          fetch-depth: 0

      # --------------------------------------------------------------
      # 단계 1.2 & 1.3: vcpkg 바이너리 캐싱 설정 (GitHub Actions Cache 연동)
      # --------------------------------------------------------------
      # 목적: vcpkg가 빌드한 라이브러리 바이너리를 GitHub Actions 캐시에 저장하고 재사용하기 위한 환경 설정을 합니다.
      #       이를 통해 동일한 의존성을 반복해서 빌드하는 시간을 크게 절약할 수 있습니다.
      # 참고: vcpkg는 이 환경 변수들이 설정되어 있고 VCPKG_BINARY_SOURCES에 'x-gha'가 포함되어 있으면,
      #       자동으로 GitHub Actions 캐시를 바이너리 소스로 활용합니다.

      # 단계 1.2: vcpkg가 GHA 캐시 URL 및 토큰에 접근할 수 있도록 환경 변수 설정
      - name: 1.2 Enable vcpkg GitHub Actions Cache Integration
        # 'actions/github-script' 액션을 사용하여 워크플로우 컨텍스트 정보에 접근하고 환경 변수를 설정합니다.
        uses: actions/github-script@v7
        with:
          # ACTIONS_CACHE_URL: GitHub Actions 캐시 서비스의 URL
          # ACTIONS_RUNTIME_TOKEN: 현재 워크플로우 실행의 인증 토큰
          script: |
            core.exportVariable('ACTIONS_CACHE_URL', process.env.ACTIONS_CACHE_URL || '');
            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env.ACTIONS_RUNTIME_TOKEN || '');

      # 단계 1.3: vcpkg가 사용할 바이너리 소스를 환경 변수로 지정
      - name: 1.3 Configure vcpkg binary caching source via Env Var
        # 'run' 키워드를 사용하여 쉘 명령어를 직접 실행합니다.
        # '>> $GITHUB_ENV' 구문은 후속 스텝에서도 사용할 수 있도록 환경 변수를 설정하는 GitHub Actions 방식입니다.
        # VCPKG_BINARY_SOURCES 환경 변수 설명:
        #   - 'clear': vcpkg의 기본 바이너리 소스 설정을 초기화합니다. (예: 로컬 캐시 등)
        #   - 'x-gha': GitHub Actions 캐시를 바이너리 소스로 사용하도록 명시합니다.
        #   - 'readwrite': 캐시에서 바이너리를 읽고(read), 빌드된 바이너리를 캐시에 쓰는(write) 작업을 모두 허용합니다.
        run: echo "VCPKG_BINARY_SOURCES=clear;x-gha,readwrite" >> $GITHUB_ENV

      # --------------------------------------------------------------
      # 단계 1.4: vcpkg 작업 디렉토리 캐싱 (다운로드 및 빌드 중간 산출물)
      # --------------------------------------------------------------
      # 목적: vcpkg가 라이브러리 소스를 다운로드하는 폴더('downloads')와 빌드 과정에서 생성하는
      #       중간 파일들이 저장되는 폴더('buildtrees')를 캐싱합니다.
      #       바이너리 캐시(1.3)와 함께 사용하면, 소스 다운로드 시간 및 라이브러리 재빌드 시간을 모두 절약할 수 있습니다.
      - name: 1.4 Cache vcpkg downloads and buildtrees directories
        # 'actions/cache' 액션 사용 (v4 버전)
        uses: actions/cache@v4
        with:
          # path: 캐싱할 디렉토리 경로 목록. 여기서는 vcpkg의 downloads와 buildtrees 폴더를 지정합니다.
          path: |
            ${{ github.workspace }}/vcpkg/downloads
            ${{ github.workspace }}/vcpkg/buildtrees
          # key: 캐시를 식별하는 고유 키. 이 키가 일치하는 캐시가 있으면 복원합니다.
          #      운영체제 종류(${runner.os})와 vcpkg 의존성 정의 파일(vcpkg.json)의 해시값을 조합하여 생성합니다.
          #      이렇게 하면, OS나 의존성이 변경될 때만 새로운 캐시를 생성하게 됩니다.
          key: vcpkg-${{ runner.os }}-${{ hashFiles('**/vcpkg.json') }}
          # restore-keys: 정확히 일치하는 key가 없을 때, 이 패턴으로 시작하는 가장 최신 캐시를 복원 시도합니다.
          #                 부분적으로라도 캐시를 활용하기 위한 fallback 전략입니다.
          restore-keys: |
            vcpkg-${{ runner.os }}-

      # --------------------------------------------------------------
      # 단계 1.5: vcpkg 부트스트랩 (vcpkg 실행 파일 빌드)
      # --------------------------------------------------------------
      # 목적: vcpkg 도구 자체를 빌드합니다. 이 과정에서 vcpkg.exe 실행 파일이 생성되며,
      #       이후 CMake 단계에서 의존성 패키지를 설치하는 데 사용됩니다.
      #       캐시된 vcpkg 폴더가 있더라도, vcpkg 버전 업데이트 등을 위해 실행하는 것이 안전할 수 있습니다.
      - name: 1.5 Bootstrap vcpkg (Build vcpkg executable)
        # vcpkg 서브모듈 내의 부트스트랩 스크립트 실행
        # -disableMetrics 플래그: vcpkg 사용 통계 전송 기능을 비활성화합니다. (선택 사항)
        run: .\vcpkg\bootstrap-vcpkg.bat -disableMetrics
        # shell: cmd 옵션: Windows 배치 파일(.bat)은 cmd 쉘에서 실행하는 것이 호환성 측면에서 더 안정적일 수 있습니다.
        shell: cmd

      # --------------------------------------------------------------
      # 단계 1.6: CMake 빌드 디렉토리 캐싱
      # --------------------------------------------------------------
      # 목적: CMake가 생성하는 빌드 구성 파일, 중간 오브젝트 파일 등이 저장되는 'build' 디렉토리를 캐싱합니다.
      #       이를 통해 후속 실행에서 CMake Configure 단계를 빠르게 완료하고,
      #       변경된 소스 코드만 증분 빌드(incremental build)하여 전체 빌드 시간을 단축합니다.
      - name: 1.6 Cache CMake build directory
        uses: actions/cache@v4
        with:
          # path: 캐싱할 대상인 'build' 디렉토리 지정.
          path: ${{ github.workspace }}/build
          # key: 캐시 식별 키. 운영체제, 모든 CMakeLists.txt 파일의 내용, vcpkg.json 파일 내용을 기반으로 생성합니다.
          #      CMake 설정이나 의존성이 변경되면 캐시가 무효화됩니다.
          key: build-${{ runner.os }}-${{ hashFiles('**/CMakeLists.txt', '**/vcpkg.json') }}
          # restore-keys: 부분적 캐시 복원을 위한 fallback 키.
          restore-keys: |
            build-${{ runner.os }}-

      # --------------------------------------------------------------
      # 단계 1.7: CMake Configure (프로젝트 생성 및 의존성 설치)
      # --------------------------------------------------------------
      # 목적: CMake를 실행하여 빌드 시스템(예: Visual Studio 솔루션 파일)을 생성합니다.
      #       이 과정에서 vcpkg 툴체인 파일을 사용하여 vcpkg의 'manifest 모드'를 활성화하고,
      #       'vcpkg.json'에 명시된 의존성 패키지들을 자동으로 설치(또는 빌드)합니다.
      #       vcpkg 캐시(1.3, 1.4)가 히트되면 이 의존성 설치 과정은 매우 빠르게 진행됩니다.
      - name: 1.7 Configure CMake project (and install dependencies via vcpkg)
        # run: | 와 함께 여러 줄로 명령어 작성 (PowerShell 사용)
        run: |
          # cmake 명령어 실행
          # -B build: 빌드 결과물을 'build' 디렉토리에 생성하도록 지정합니다.
          # -S .: 소스 코드 디렉토리를 현재 디렉토리('.')로 지정합니다.
          # -A x64: 빌드 아키텍처를 64비트로 지정합니다. (Visual Studio Generator 사용 시)
          cmake -B build -S . -A x64 `
            # -DCMAKE_TOOLCHAIN_FILE=...: vcpkg에서 제공하는 툴체인 파일을 지정합니다.
            #                            이를 통해 CMake가 vcpkg를 인식하고 manifest 모드로 동작하게 됩니다.
            -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}\vcpkg\scripts\buildsystems\vcpkg.cmake `
            # -DCMAKE_BUILD_TYPE=Release: 빌드 유형을 'Release'로 설정합니다. (최적화된 빌드)
            #                            CMake 변수를 설정할 때는 -D<변수명>=<값> 형식을 사용합니다.
            -DCMAKE_BUILD_TYPE=Release
        # shell: powershell 옵션: Windows 환경의 기본 쉘은 PowerShell이며, 백틱(`)을 줄 연속 문자로 사용합니다. 명시적으로 지정.
        shell: powershell

      # --------------------------------------------------------------
      # 단계 1.8: CMake Build (프로젝트 컴파일)
      # --------------------------------------------------------------
      # 목적: 앞서 Configure 단계에서 생성된 빌드 시스템을 사용하여 실제 프로젝트 코드를 컴파일합니다.
      #       빌드 디렉토리 캐시(1.6)가 히트되고 소스 코드 변경이 없다면, 이 단계는 거의 즉시 완료됩니다.
      - name: 1.8 Build Project using CMake (Release configuration)
        # --build <dir>: 지정된 디렉토리('build')의 프로젝트를 빌드합니다.
        # --config Release: 빌드할 구성(Configuration)을 'Release'로 명시합니다.
        #                   (Multi-configuration generator, 예를 들어 Visual Studio 에서 필요)
        run: cmake --build build --config Release

      # --------------------------------------------------------------
      # 단계 1.9: 테스트 실행 (CTest 사용)
      # --------------------------------------------------------------
      # 목적: 빌드된 코드가 예상대로 동작하는지 확인하기 위해 단위 테스트를 실행합니다.
      #       CTest는 CMake와 통합된 테스트 실행 도구입니다.
      - name: 1.9 Run tests via CTest
        run: |
          # 테스트 실행 파일 및 설정이 있는 빌드 디렉토리로 이동
          cd build
          # CTest 실행
          # -C Release: 테스트할 빌드 구성(Configuration)을 'Release'로 지정합니다.
          # --output-on-failure: 테스트가 실패할 경우에만 상세 출력을 표시합니다. 성공 시에는 조용히 넘어갑니다.
          ctest -C Release --output-on-failure
          # 원래 디렉토리로 복귀 (필수는 아니지만 좋은 습관)
          cd ..

  # ==============================================================
  # Job 2: Doxygen 문서 생성 (Windows 환경)
  # ==============================================================
  # 이 Job의 목적: 소스 코드를 기반으로 Doxygen 도구를 사용하여 개발 문서를 생성하고,
  #               생성된 문서를 GitHub Pages 배포용 아티팩트로 업로드합니다.
  # 이 Job은 빌드 및 테스트 Job(cmake_build_test)이 성공적으로 완료된 후에만 실행됩니다.
  generate_docs:
    # Job 이름
    name: 2. Generate Documentation (Windows)
    # Job 실행 환경
    # 현재 Doxygen 설치에 Chocolatey(choco)를 사용하므로 Windows 환경이 필요합니다.
    # 만약 'crazy-max/ghaction-setup-doxygen' 액션 등을 사용하면 Linux 환경에서도 가능할 수 있습니다.
    runs-on: windows-latest
    # Job 의존성 설정: 'cmake_build_test' Job이 성공해야 이 Job이 시작됩니다.
    needs: cmake_build_test

    steps:
      # --------------------------------------------------------------
      # 단계 2.1: 소스 코드 체크아웃 (문서 생성을 위해 필요)
      # --------------------------------------------------------------
      # 목적: Doxygen이 분석할 소스 코드를 다시 체크아웃합니다.
      #       각 Job은 독립적인 환경에서 실행되므로, 이전 Job의 파일 시스템을 공유하지 않습니다.
      - name: 2.1 Check out source code for documentation
        uses: actions/checkout@v4
        # 최적화 참고: 만약 Doxyfile이 오직 메인 저장소의 최신 소스 코드만 필요로 하고,
        #            Git 히스토리나 서브모듈 내용을 참조하지 않는다면, 아래 주석 처리된 옵션을 사용하여
        #            체크아웃 속도를 향상시킬 수 있습니다.
        # with:
        #   fetch-depth: 1   # 가장 최신 커밋만 가져옵니다.
        #   submodules: false # 서브모듈은 체크아웃하지 않습니다.
        # 하지만, 확실하지 않다면 안전하게 기본 설정(위 옵션 없이)을 사용하는 것이 좋습니다.

      # --------------------------------------------------------------
      # 단계 2.2: Doxygen 설치
      # --------------------------------------------------------------
      # 목적: 문서 생성 도구인 Doxygen을 설치합니다.
      - name: 2.2 Install Doxygen tool
        # Windows 패키지 관리자인 Chocolatey(choco)를 사용하여 doxygen.portable 패키지를 설치합니다.
        # -y 플래그: 설치 중 확인 프롬프트에 자동으로 'yes'로 응답합니다.
        run: choco install doxygen.portable -y

      # --------------------------------------------------------------
      # 단계 2.3: Doxygen 문서 생성 실행
      # --------------------------------------------------------------
      # 목적: Doxygen 설정을 담고 있는 Doxyfile을 사용하여 문서를 생성합니다.
      - name: 2.3 Generate Documentation using Doxygen
        # doxygen 명령어 실행. 인자로 Doxyfile의 경로를 전달합니다.
        # 이 명령은 저장소 루트에서 실행되므로, './docs/Doxyfile'과 같이 루트 기준 상대 경로를 사용합니다.
        run: doxygen ./docs/Doxyfile

      # --------------------------------------------------------------
      # 단계 2.4: GitHub Pages 배포용 아티팩트 업로드
      # --------------------------------------------------------------
      # 목적: Doxygen이 생성한 결과물(일반적으로 HTML 파일들)을 다음 배포 Job에서 사용할 수 있도록
      #       GitHub Pages 전용 아티팩트로 업로드합니다.
      - name: 2.4 Upload artifact for Pages deployment
        # 'actions/upload-pages-artifact' 액션 사용 (v3 버전)
        # 이 액션은 GitHub Pages 배포 워크플로우를 위해 특별히 설계되었습니다.
        uses: actions/upload-pages-artifact@v3
        with:
          # path: 업로드할 파일 또는 디렉토리의 경로를 지정합니다.
          #       Doxyfile의 OUTPUT_DIRECTORY 설정과 HTML 생성 경로를 확인하여 정확히 지정해야 합니다.
          #       예시: Doxygen이 './docs_output' 디렉토리에 HTML 파일을 생성했다면, './docs_output/html' 또는 './docs_output'을 지정합니다.
          path: ./docs/docs_output/html # Doxyfile 설정에 따라 실제 경로로 수정하세요.

  # ==============================================================
  # Job 3: GitHub Pages 배포 (Ubuntu 환경)
  # ==============================================================
  # 이 Job의 목적: 이전 Job에서 생성 및 업로드한 문서 아티팩트를 사용하여 GitHub Pages에 배포합니다.
  # 이 Job은 문서 생성 Job(generate_docs)이 성공적으로 완료된 후에만 실행됩니다.
  deploy_pages:
    # Job 이름
    name: 3. Deploy Documentation to GitHub Pages
    # Job 실행 환경
    # 배포 작업 자체는 특별한 OS 요구사항이 없으므로, 일반적으로 빠르고 비용 효율적인 Ubuntu 환경을 사용합니다.
    runs-on: ubuntu-latest
    # Job 의존성 설정: 'generate_docs' Job이 성공해야 이 Job이 시작됩니다.
    needs: generate_docs

    # --------------------------------------------------------------
    # 권한 설정: GitHub Pages 배포에 필요한 권한 부여
    # --------------------------------------------------------------
    # 목적: 이 Job이 GitHub Pages 콘텐츠를 쓰고, OIDC(OpenID Connect) 토큰을 사용하여
    #       GitHub Actions가 안전하게 인증하고 배포할 수 있도록 권한을 설정합니다.
    permissions:
      # pages: write 권한: GitHub Pages 콘텐츠를 업데이트(쓰기)할 수 있는 권한입니다.
      pages: write
      # id-token: write 권한: GitHub Actions가 OIDC 토큰을 요청하고 사용할 수 있는 권한입니다.
      #                     actions/deploy-pages 액션은 이 토큰을 사용하여 GitHub에 인증합니다.
      id-token: write

    # --------------------------------------------------------------
    # 배포 환경 설정
    # --------------------------------------------------------------
    # 목적: 배포 대상 환경을 'github-pages'로 지정하고, 배포 완료 후 해당 페이지의 URL을 제공합니다.
    environment:
      # name: github-pages 로 지정하면, 저장소의 Pages 설정과 연동됩니다.
      name: github-pages
      # url: 배포 후 생성되는 페이지 URL을 워크플로우 실행 결과에 표시합니다.
      #      ${{ steps.deployment.outputs.page_url }} 값은 아래 deploy 단계(id: deployment)의 출력값을 참조합니다.
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      # --------------------------------------------------------------
      # 단계 3.1: GitHub Pages 배포 실행
      # --------------------------------------------------------------
      # 목적: 실제 배포 작업을 수행합니다.
      - name: 3.1 Deploy to GitHub Pages
        # 단계(Step)에 ID 부여 ('deployment') - environment의 url 설정에서 이 ID를 사용하여 출력값 참조
        id: deployment
        # 'actions/deploy-pages' 액션 사용 (v4 버전)
        # 이 액션은 'upload-pages-artifact'로 업로드된 아티팩트를 자동으로 다운로드하여,
        # 설정된 'github-pages' 환경에 맞게 배포하는 모든 과정을 처리합니다.
        uses: actions/deploy-pages@v4
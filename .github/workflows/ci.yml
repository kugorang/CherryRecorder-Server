# GitHub Actions 워크플로우 이름 정의
name: CI - Multi-Job Linux

# ==================================================
# 워크플로우 실행 조건 (Triggers)
# ==================================================
# 어떤 이벤트가 발생했을 때 이 워크플로우를 실행할지 정의합니다.
on:
  # 1. 'main' 브랜치로 코드가 푸시(push)될 때 실행됩니다.
  push:
    branches: [ main ]
  # 2. 'main' 브랜치를 대상으로 하는 풀 리퀘스트(pull request)가 생성되거나 업데이트될 때 실행됩니다.
  pull_request:
    branches: [ main ]

# ==================================================
# 워크플로우 작업 (Jobs)
# ==================================================
# 워크플로우는 하나 이상의 Job으로 구성되며, 각 Job은 독립적인 환경에서 실행됩니다.
# 이 워크플로우는 3개의 Job으로 구성되어 순차적으로 실행됩니다: 빌드/테스트 -> 문서 생성 -> 배포
jobs:
  # ==============================================================
  # Job 1: CMake 프로젝트 빌드 및 테스트 (Linux 환경)
  # ==============================================================
  # 목적: 프로젝트 소스 코드를 컴파일하고 단위 테스트를 실행하여 코드의 기본적인 무결성을 검증합니다.
  # 특징: vcpkg 의존성 관리, CMake 빌드 시스템 사용, Linux(Ubuntu) 환경에서 실행됩니다. (Docker 배포 환경과 일치)
  cmake_build_test:
    name: 1. CMake Build & Test (Linux)
    # 실행 환경: Docker 이미지 및 최종 배포 환경과 일치시키기 위해 Ubuntu 최신 버전을 사용합니다.
    runs-on: ubuntu-latest

    # Job 단계 (Steps): Job 내에서 순차적으로 실행되는 명령어 또는 액션의 목록입니다.
    steps:
      # --------------------------------------------------------------
      # 단계 1.0: 필수 빌드 도구 설치 (Linux Runner)
      # --------------------------------------------------------------
      # 목적: Ubuntu Runner에 C++ 컴파일러(g++), CMake, Git 등 빌드 및 vcpkg에 필요한 도구들을 설치합니다.
      # 참고: libmysqlclient-dev는 vcpkg가 mysql-connector-cpp를 빌드/링크할 때 필요할 수 있습니다.
      - name: 1.0 Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential \
            cmake \
            git \
            curl \
            zip \
            unzip \
            tar \
            pkg-config \
            ninja-build \
            # libmysqlclient-dev # mysql-connector-cpp 링크 시 필요하면 주석 해제

      # --------------------------------------------------------------
      # 단계 1.1: 소스 코드 체크아웃
      # --------------------------------------------------------------
      # 목적: Git 저장소의 최신 코드를 Runner로 내려받습니다.
      - name: 1.1 Check out source code repository
        uses: actions/checkout@v4
        with:
          submodules: true # vcpkg 서브모듈 포함
          fetch-depth: 0   # vcpkg baseline 조회를 위해 전체 Git 히스토리 필요

      # --------------------------------------------------------------
      # 단계 1.2 & 1.3: vcpkg 바이너리 캐싱 활성화 (GHA 연동)
      # --------------------------------------------------------------
      # 목적: vcpkg 빌드 시간 단축을 위해 GHA 캐시 연동 설정
      - name: 1.2 Enable vcpkg GitHub Actions Cache Integration
        uses: actions/github-script@v7
        with:
          script: |
            core.exportVariable('ACTIONS_CACHE_URL', process.env.ACTIONS_CACHE_URL || '');
            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env.ACTIONS_RUNTIME_TOKEN || '');
      - name: 1.3 Configure vcpkg binary caching source via Env Var
        run: echo "VCPKG_BINARY_SOURCES=clear;x-gha,readwrite" >> $GITHUB_ENV

      # --------------------------------------------------------------
      # 단계 1.4: vcpkg 작업 디렉토리 캐싱 (다운로드, 빌드 중간 산출물)
      # --------------------------------------------------------------
      # 목적: vcpkg 소스 다운로드 및 빌드 중간 파일 캐싱
      - name: 1.4 Cache vcpkg downloads and buildtrees directories
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/vcpkg/downloads
            ${{ github.workspace }}/vcpkg/buildtrees
          # key의 runner.os 부분은 자동으로 'Linux'로 변경되어 적용됩니다.
          key: vcpkg-${{ runner.os }}-${{ hashFiles('**/vcpkg.json') }}
          restore-keys: |
            vcpkg-${{ runner.os }}-

      # --------------------------------------------------------------
      # 단계 1.5: vcpkg 부트스트랩 (Linux 용)
      # --------------------------------------------------------------
      # 목적: Linux 환경용 vcpkg 실행 파일을 생성합니다.
      - name: 1.5 Bootstrap vcpkg (Build vcpkg executable for Linux)
        # Linux 환경에서는 bootstrap-vcpkg.sh 스크립트 사용
        run: ./vcpkg/bootstrap-vcpkg.sh -disableMetrics

      # --------------------------------------------------------------
      # 단계 1.6: CMake 빌드 디렉토리 캐싱
      # --------------------------------------------------------------
      # 목적: CMake 빌드 디렉토리 캐싱 (Windows와 동일)
      - name: 1.6 Cache CMake build directory
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/build
          # key의 runner.os 부분은 자동으로 'Linux'로 변경되어 적용됩니다.
          key: build-${{ runner.os }}-${{ hashFiles('**/CMakeLists.txt', '**/vcpkg.json') }}
          restore-keys: |
            build-${{ runner.os }}-

      # --------------------------------------------------------------
      # 단계 1.7: CMake Configure (Linux 용)
      # --------------------------------------------------------------
      # 목적: Linux 환경에서 CMake를 구성하고 vcpkg 의존성을 해결합니다.
      - name: 1.7 Configure CMake project (Linux)
        # CMake 명령어 실행 (Linux 환경에 맞게 조정)
        # -G Ninja: Ninja 빌드 시스템 사용 (CMakePresets.json과 일치, 일반적으로 빠름)
        # -A x64 제거: Linux에서는 아키텍처를 이렇게 지정하지 않음 (툴체인이 처리)
        # vcpkg 툴체인 경로 구분자 변경 (/)
        # 줄 연속 불필요 (한 줄로 작성) 또는 Bash의 백슬래시(\) 사용
        run: >
          cmake -S . -B build
          -G Ninja
          -DCMAKE_BUILD_TYPE=Release
          -DCMAKE_TOOLCHAIN_FILE=${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake
          -DVCPKG_TARGET_TRIPLET=x64-linux # Linux용 vcpkg triplet 명시

      # --------------------------------------------------------------
      # 단계 1.8: CMake Build (Linux 용)
      # --------------------------------------------------------------
      # 목적: Linux 환경에서 프로젝트를 컴파일합니다.
      - name: 1.8 Build Project using CMake (Linux)
        # --config Release 제거: Ninja 등 단일 구성 생성기에서는 필요 없음
        # -j $(nproc): 사용 가능한 CPU 코어를 최대한 활용하여 병렬 빌드 수행 (속도 향상)
        run: cmake --build build -j $(nproc)

      # --------------------------------------------------------------
      # 단계 1.9: 테스트 실행 (Linux 용)
      # --------------------------------------------------------------
      # 목적: Linux 환경에서 빌드된 테스트를 실행합니다.
      - name: 1.9 Run tests via CTest (Linux)
        # CTest 실행 (Linux 환경에 맞게 조정)
        # -C Release 제거: 단일 구성 생성기에서는 필요 없음
        run: |
          cd build
          ctest --output-on-failure
          cd ..

  # ==============================================================
  # Job 2: Doxygen 문서 생성 (Linux 환경)
  # ==============================================================
  # 목적: 프로젝트 소스 코드를 분석하여 Doxygen으로 API 문서를 생성하고, 배포를 위해 준비합니다.
  # 의존성: 이 Job은 'cmake_build_test' Job이 성공해야만 시작됩니다.
  generate_docs:
    name: 2. Generate Documentation (Linux)
    # 실행 환경: Doxygen 도구를 apt로 설치할 수 있는 Ubuntu 환경 사용
    runs-on: ubuntu-latest
    needs: cmake_build_test # 이전 Job(빌드/테스트) 성공 시 실행

    steps:
      # --------------------------------------------------------------
      # 단계 2.1: 소스 코드 체크아웃 (문서 생성을 위해)
      # --------------------------------------------------------------
      - name: 2.1 Check out source code for documentation
        uses: actions/checkout@v4
        # 최적화 참고 (필요시 주석 해제)
        # with:
        #   fetch-depth: 1
        #   submodules: false

      # --------------------------------------------------------------
      # 단계 2.2: Doxygen 설치 (Linux Runner)
      # --------------------------------------------------------------
      # 목적: Ubuntu Runner에 Doxygen 및 관련 도구(Graphviz) 설치
      - name: 2.2 Install Doxygen tool
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends doxygen graphviz

      # --------------------------------------------------------------
      # 단계 2.3: Doxygen 문서 생성 실행
      # --------------------------------------------------------------
      - name: 2.3 Generate Documentation using Doxygen
        run: doxygen ./docs/Doxyfile

      # --------------------------------------------------------------
      # 단계 2.4: GitHub Pages 배포용 아티팩트 업로드
      # --------------------------------------------------------------
      - name: 2.4 Upload artifact for Pages deployment
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./docs/docs_output/html # 실제 Doxygen 출력 경로 확인 필요

  # ==============================================================
  # Job 3: GitHub Pages 배포 (Ubuntu 환경)
  # ==============================================================
  # 목적: 'generate_docs' Job에서 생성한 문서를 GitHub Pages 사이트로 게시(배포)합니다.
  # 의존성: 이 Job은 'generate_docs' Job이 성공해야만 시작됩니다.
  deploy_pages:
    name: 3. Deploy Documentation to GitHub Pages
    runs-on: ubuntu-latest
    needs: generate_docs
    permissions:
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: 3.1 Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  # ==============================================================
  # Job 4: Docker 이미지 빌드 및 AWS ECR 푸시 (Ubuntu 환경)
  # ==============================================================
  docker_build_push:
    name: 4. Build and Push Docker Image to AWS ECR
    runs-on: ubuntu-latest
    needs: cmake_build_test # Linux 빌드/테스트 성공 후 실행

    steps:
      # 단계 4.1: 소스 코드 체크아웃
      - name: 4.1 Check out source code repository
        uses: actions/checkout@v4
        # with: { fetch-depth: 1 } # 전체 히스토리 불필요 시

      # 단계 4.2: AWS 자격 증명 설정
      - name: 4.2 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          # (OIDC 사용 시 설정 변경)

      # 단계 4.3: AWS ECR 로그인
      - name: 4.3 Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 단계 4.4: Docker 이미지 빌드 및 태그 지정
      - name: 4.4 Build and tag Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.AWS_ECR_REPOSITORY }} # Secret 변수 사용
          IMAGE_TAG: ${{ github.sha }}
        # Dockerfile 사용하여 빌드, ECR 주소 및 commit SHA, latest로 태그 지정
        run: docker build . --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest

      # 단계 4.5: Docker 이미지 푸시
      - name: 4.5 Push Docker image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.AWS_ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  # ==============================================================
  # Job 5: AWS에 애플리케이션 배포 (Ubuntu 환경)
  # ==============================================================
  # 목적: ECR에 푸시된 최신 Docker 이미지를 사용하여 AWS 환경에 배포(업데이트)합니다.
  # 주의: 이 Job의 내용은 사용하는 AWS 서비스(EC2, ECS, EKS, CodeDeploy 등)에 따라 완전히 달라집니다!
  deploy_aws:
    name: 5. Deploy Application to AWS (Example)
    runs-on: ubuntu-latest
    needs: docker_build_push # Docker 이미지 푸시 성공 후 실행

    steps:
      # 단계 5.1: AWS 자격 증명 설정
      - name: 5.1 Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 단계 5.2: 배포 실행 (실제 환경에 맞게 수정 필수!)
      - name: 5.2 Trigger deployment (Replace with actual commands)
        run: |
          echo "AWS 배포 명령어를 여기에 작성하세요."
          echo "예: aws ecs update-service --cluster ... --force-new-deployment"
          echo "배포 및 애플리케이션 시작 대기..."
          sleep 60 # 실제 필요한 대기 시간으로 조정

  # ==============================================================
  # Job 6: 배포된 서버 Telnet 확인 (Ubuntu 환경)
  # ==============================================================
  # 목적: AWS에 배포된 애플리케이션 서버 포트로 연결을 시도하여 응답 여부를 확인합니다.
  telnet_check:
    name: 6. Perform Connection Check to AWS Server
    runs-on: ubuntu-latest
    needs: deploy_aws # AWS 배포 성공 후 실행

    steps:
      # 단계 6.1: 연결 확인 도구 설치 (netcat 권장)
      - name: 6.1 Install netcat
        run: sudo apt-get update && sudo apt-get install -y --no-install-recommends netcat

      # 단계 6.2: 연결 시도 (Telnet 대신 nc 사용)
      - name: 6.2 Attempt connection using netcat
        env:
          SERVER_ADDRESS: ${{ secrets.SERVER_ADDRESS }} # Secret 변수 사용
          SERVER_PORT: ${{ secrets.SERVER_PORT }}       # Secret 변수 사용
        # nc 명령어로 지정된 주소/포트에 연결 시도 (-z: 스캔, -v: 상세, -w 5: 타임아웃 5초)
        run: |
          echo "Attempting to connect to $SERVER_ADDRESS on port $SERVER_PORT..."
          if nc -z -v -w 5 $SERVER_ADDRESS $SERVER_PORT; then
            echo "Connection successful!"
          else
            echo "Connection failed!"
            exit 1 # 연결 실패 시 워크플로우 실패 처리
          fi
# .github/workflows/reusable-connection-check.yml
name: Reusable - Connection Check (HTTP & TCP)

on:
  workflow_call:
    inputs:
      server_address:
        description: 'ë°°í¬ëœ ì„œë²„ì˜ ì£¼ì†Œ (ì˜ˆ: NLB DNS ì´ë¦„, IP ì£¼ì†Œ)'
        required: true
        type: string
      health_check_port:
        description: 'HTTP Health Check ì—”ë“œí¬ì¸íŠ¸ í¬íŠ¸ ë²ˆí˜¸'
        required: true
        type: string
        default: "8080"
      http_port:
        description: 'HTTP ì„œë²„ í¬íŠ¸ ë²ˆí˜¸'
        required: false
        type: string
        default: "58080"
      websocket_port:
        description: 'WebSocket Chat ì„œë²„ í¬íŠ¸ ë²ˆí˜¸'
        required: false
        type: string
        default: "33335"
      max_attempts:
        description: 'ê° í¬íŠ¸ì— ëŒ€í•œ ìµœëŒ€ ì—°ê²° ì‹œë„ íšŸìˆ˜'
        required: false
        type: string
        default: '12'
      retry_delay_seconds:
        description: 'ì¬ì‹œë„ ê°„ ê¸°ë³¸ ì§€ì—° ì‹œê°„ (ì´ˆ) - ì‹¤ì œ ì§€ì—°ì€ ì‹œë„ íšŸìˆ˜ì— ë”°ë¼ ì¦ê°€'
        required: false
        type: string
        default: '15'
      connect_timeout_seconds:
        description: 'ê° ì—°ê²° ì‹œë„ì— ëŒ€í•œ íƒ€ì„ì•„ì›ƒ ì‹œê°„ (ì´ˆ)'
        required: false
        type: string
        default: '10'
      expected_http_response:
        description: 'HTTP Health Check ì‘ë‹µ ë³¸ë¬¸ì— í¬í•¨ë˜ì–´ì•¼ í•˜ëŠ” ë¬¸ìì—´ (ì„ íƒ ì‚¬í•­)'
        required: false
        type: string
        default: ''
      initial_wait_seconds:
        description: 'ì—°ê²° í™•ì¸ ì‹œì‘ ì „ ì´ˆê¸° ëŒ€ê¸° ì‹œê°„ (ì´ˆ)'
        required: false
        type: string
        default: '30'
    outputs:
      connection_status:
        description: "ëª¨ë“  ì—°ê²° í™•ì¸ ìµœì¢… ê²°ê³¼ ('success' ë˜ëŠ” 'fail')"
        value: ${{ jobs.check_job.outputs.status }}

jobs:
  check_job:
    name: Check Connection to Server Ports
    runs-on: ubuntu-24.04
    env:
      HTTP_PORT: ${{ inputs.http_port }}
      WEBSOCKET_PORT: ${{ inputs.websocket_port }}
    outputs:
      status: ${{ steps.set-status.outputs.final_status }}
    steps:
      - name: Install network tools
        run: |
          sudo apt-get update && \
          sudo apt-get install -y --no-install-recommends netcat-openbsd curl dnsutils && \
          sudo rm -rf /var/lib/apt/lists/*
        shell: bash

      # DNS ê²€ì¦ ë‹¨ê³„ ì¶”ê°€
      - name: Verify DNS resolution
        run: |
          echo "Resolving hostname: ${{ inputs.server_address }}"
          IP_ADDRESSES=$(dig +short ${{ inputs.server_address }})
          
          if [ -z "$IP_ADDRESSES" ]; then
            echo "Warning: Could not resolve hostname ${{ inputs.server_address }}"
            echo "This might be a DNS issue or the hostname might be incorrect."
          else
            echo "Hostname resolved to: $IP_ADDRESSES"
          fi
        shell: bash
        continue-on-error: true

      # ì´ˆê¸° ëŒ€ê¸° ì‹œê°„ ì¶”ê°€ (ECS íƒœìŠ¤í¬ê°€ ì‹œì‘ë˜ëŠ” ì‹œê°„ í™•ë³´)
      - name: Initial wait for service startup
        run: |
          INITIAL_WAIT=${{ inputs.initial_wait_seconds || 30 }}
          echo "Waiting $INITIAL_WAIT seconds for ECS service to start..."
          echo "This gives time for:"
          echo "  - ECS task to be scheduled and started"
          echo "  - Container to pull image and initialize"
          echo "  - Health checks to begin"
          sleep $INITIAL_WAIT
        shell: bash

      - name: Perform Connection Checks
        id: connection-check
        run: |
          MAX_ATTEMPTS=${{ inputs.max_attempts || 12 }}
          BASE_RETRY_DELAY=${{ inputs.retry_delay_seconds || 15 }}
          CONNECT_TIMEOUT=${{ inputs.connect_timeout_seconds || 10 }}
          
          # ì§€ìˆ˜ ë°±ì˜¤í”„ í•¨ìˆ˜
          calculate_delay() {
            local attempt=$1
            # ì§€ìˆ˜ ë°±ì˜¤í”„: delay = base * (1.5 ^ (attempt - 1)), ìµœëŒ€ 120ì´ˆ
            local delay=$(awk "BEGIN {print int($BASE_RETRY_DELAY * (1.5 ^ ($attempt - 1)))}")
            if [ $delay -gt 120 ]; then
              delay=120
            fi
            echo $delay
          }
          
          # --- 1. HTTPS Health Endpoint í™•ì¸ ---
          echo "=== Checking HTTPS endpoint: https://${{ inputs.server_address }}:${HTTP_PORT}/health ==="
          
          attempt=1
          total_wait_time=0
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            echo ""
            echo "Health Check Attempt $attempt/$MAX_ATTEMPTS (Total wait time: ${total_wait_time}s)"
            echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
            
            # curlì˜ verbose ëª¨ë“œë¡œ ë” ìì„¸í•œ ì •ë³´ ì¶œë ¥
            echo "Running: curl -sSv --fail --connect-timeout $CONNECT_TIMEOUT https://${{ inputs.server_address }}:${HTTP_PORT}/health"
            if curl -sSv --fail --connect-timeout $CONNECT_TIMEOUT "https://${{ inputs.server_address }}:${HTTP_PORT}/health" 2>&1; then
              echo "âœ… Health check successful on port ${HTTP_PORT}!"
              break
            else
              curl_exit_code=$?
              echo "âŒ Health check failed with exit code: $curl_exit_code"
              
              # curl ì˜¤ë¥˜ ì½”ë“œ í•´ì„
              case $curl_exit_code in
                7) echo "   â†’ Connection refused (server might not be ready yet)" ;;
                28) echo "   â†’ Connection timeout (server might be overloaded)" ;;
                22) echo "   â†’ HTTP error response (check server logs)" ;;
                60) echo "   â†’ SSL certificate problem" ;;
                *) echo "   â†’ Unknown error (check curl documentation)" ;;
              esac
            fi
            
            if [ $attempt -eq $MAX_ATTEMPTS ]; then
              echo ""
              echo "âŒ Error: HTTPS Health check failed after $MAX_ATTEMPTS attempts."
              echo "Total time waited: ${total_wait_time} seconds"
              echo "Consider checking:"
              echo "  - ECS task logs in CloudWatch"
              echo "  - Target group health in NLB"
              echo "  - Security group rules"
              exit 1
            fi
            
            # ì§€ìˆ˜ ë°±ì˜¤í”„ ê³„ì‚°
            RETRY_DELAY=$(calculate_delay $attempt)
            total_wait_time=$((total_wait_time + RETRY_DELAY))
            
            echo "â³ Health check failed, retrying in $RETRY_DELAY seconds..."
            echo "   (Using exponential backoff strategy)"
            sleep $RETRY_DELAY
            attempt=$((attempt+1))
          done

          # --- 2. WSS (TLS) ì—°ê²° í™•ì¸ (openssl ì‚¬ìš©) ---
          echo ""
          echo "=== Checking WSS (TLS) endpoint: ${{ inputs.server_address }}:${WEBSOCKET_PORT} ==="
          
          attempt=1
          total_wait_time=0
          while [ $attempt -le $MAX_ATTEMPTS ]; do
            echo ""
            echo "WSS Check Attempt $attempt/$MAX_ATTEMPTS (Total wait time: ${total_wait_time}s)"
            echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
            
            # openssl s_clientë¥¼ ì‚¬ìš©í•˜ì—¬ TLS í•¸ë“œì…°ì´í¬ê°€ ì„±ê³µí•˜ëŠ”ì§€ í™•ì¸
            echo "Running: openssl s_client -connect ${{ inputs.server_address }}:${WEBSOCKET_PORT}"
            if timeout $CONNECT_TIMEOUT openssl s_client -connect ${{ inputs.server_address }}:${WEBSOCKET_PORT} < /dev/null 2>&1 | grep -q "SSL handshake has read"; then
              echo "âœ… WSS (TLS) handshake successful on port ${WEBSOCKET_PORT}!"
              break
            else
              echo "âŒ WSS (TLS) connection test failed"
            fi
            
            if [ $attempt -eq $MAX_ATTEMPTS ]; then
              echo ""
              echo "âŒ Error: WSS (TLS) connection test failed after $MAX_ATTEMPTS attempts."
              echo "Total time waited: ${total_wait_time} seconds"
              exit 1
            fi
            
            # ì§€ìˆ˜ ë°±ì˜¤í”„ ê³„ì‚°
            RETRY_DELAY=$(calculate_delay $attempt)
            total_wait_time=$((total_wait_time + RETRY_DELAY))
            
            echo "â³ WSS (TLS) connection test failed, retrying in $RETRY_DELAY seconds..."
            sleep $RETRY_DELAY
            attempt=$((attempt+1))
          done
          
          echo ""
          echo "ğŸ‰ All connection checks passed successfully!"
          exit 0
        shell: bash
        # continue-on-error ì œê±°í•˜ì—¬ ì‹¤íŒ¨ ì‹œ stepì´ ì‹¤íŒ¨ë¡œ í‘œì‹œë˜ë„ë¡ í•¨

      # ìµœì¢… ìƒíƒœ ì„¤ì •
      - name: Set final connection status
        id: set-status
        if: always()
        run: |
          # connection-check stepì˜ ê²°ê³¼ë¥¼ í™•ì¸
          CONNECTION_RESULT="${{ steps.connection-check.outcome }}"
          
          if [ "$CONNECTION_RESULT" = "success" ]; then
            echo "âœ… All connection checks passed successfully!"
            echo "final_status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Connection checks failed!"
            echo "Connection check result: $CONNECTION_RESULT"
            echo "final_status=fail" >> $GITHUB_OUTPUT
            # ëª…ì‹œì ìœ¼ë¡œ ì‹¤íŒ¨ ë°˜í™˜
            exit 1
          fi
        shell: bash